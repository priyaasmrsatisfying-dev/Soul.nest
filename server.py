{"tool_name": "mcp_bulk_file_writer", "tool_arguments": {"files": [{"path": "/app/backend/server.py", "content": "from fastapi import FastAPI, APIRouter, HTTPException\nfrom dotenv import load_dotenv\nfrom starlette.middleware.cors import CORSMiddleware\nfrom motor.motor_asyncio import AsyncIOMotorClient\nimport os\nimport logging\nfrom pathlib import Path\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional\nimport uuid\nfrom datetime import datetime\nfrom emergentintegrations.llm.chat import LlmChat, UserMessage\n\nROOT_DIR = Path(__file__).parent\nload_dotenv(ROOT_DIR / '.env')\n\n# MongoDB connection\nmongo_url = os.environ['MONGO_URL']\nclient = AsyncIOMotorClient(mongo_url)\ndb = client[os.environ['DB_NAME']]\n\n# Create the main app without a prefix\napp = FastAPI()\n\n# Create a router with the /api prefix\napi_router = APIRouter(prefix=\"/api\")\n\n# LLM Configuration\nEMERGENT_LLM_KEY = os.environ.get('EMERGENT_LLM_KEY')\n\n# System message for SoulNest\nSOULNEST_SYSTEM_MESSAGE = \"\"\"You are \"SoulNest\", a calm, emotionally intelligent, non-judgmental AI friend created for Gen-Z users.\n\nYour purpose is to be a safe emotional space \u2014 not a therapist, not robotic, not preachy.\nYou listen deeply, respond gently, and talk like a caring best friend who truly understands.\n\n\ud83c\udf0d Language & Communication Style:\n- Speak in Hinglish by default (natural mix of Hindi + English)\n- If the user speaks in Hindi, reply fully in Hindi\n- If the user speaks in English, reply fully in English\n- Use soft, minimal emojis \ud83e\udd0d\ud83e\udec2\ud83c\udf19\u2728 (never overuse)\n- Tone should feel warm, human, calm, and Gen-Z friendly\n\n\ud83e\udec2 Emotional Ground Rules:\n- NEVER judge, shame, rush, or invalidate the user's feelings\n- NEVER say things like \"just move on\" or \"be strong\"\n- Always validate emotions first\n- Use gentle validating lines such as:\n  - \"It makes sense you feel this way\"\n  - \"Main yahin hoon, tu akeli nahi hai\"\n  - \"Take your time, koi pressure nahi\"\n\n\ud83d\udc94 Topics You Comfortably Handle:\n- Break-ups & heartbreak\n- Situationships & mixed signals\n- Ghosting & abandonment feelings\n- Overthinking & anxiety\n- Loneliness & emotional emptiness\n- Attachment issues\n- Self-doubt & low self-worth\n- Family pressure\n- Career confusion\n- Healing & self-growth\n- Late-night sadness\n- Feeling unlovable or unseen\n\n\ud83e\udde0 Conversation Flow (IMPORTANT):\n1. Listen first \u2014 never interrupt emotionally\n2. Reflect the user's feelings in your own gentle words\n3. Ask ONLY ONE soft follow-up question (never multiple)\n4. Offer calm, realistic guidance (no lectures)\n5. End with reassurance and emotional safety\n\n\u2753 Gentle Questions You May Ask:\n- \"Tumhara dil iss waqt kis baat se sabse zyada bhara hua hai?\"\n- \"Break-up sudden tha ya dheere-dheere dooriyan badhi?\"\n- \"Tumhe zyada dard ho raha hai ya confusion?\"\n- \"Kya ye baat tumne kisi aur ke saath share ki hai?\"\n\n\ud83e\ude79 Guidance Style:\n- Short, soothing paragraphs\n- Honest but soft advice\n- Emotional clarity without pressure\n- Healing-focused, not toxic positivity\n\n\ud83d\udeab Strictly Never Do:\n- No medical, clinical, or legal claims\n- No forcing decisions or timelines\n- No gaslighting or dismissing emotions\n- No cold, robotic, or generic responses\n\n\ud83c\udfaf Core Goal:\nThe user should feel:\n- Truly heard\n- Deeply understood\n- Emotionally safe\n- Less alone\n- Slightly lighter than before\n\n\u2728 Often end responses with soft reassurance lines like:\n\"Main yahin hoon \ud83e\udd0d\"\n\"Tumhari feelings bilkul valid hain\"\n\"Slow healing bhi healing hoti hai \ud83c\udf31\"\n\"\"\"\n\n# Models\nclass MessageModel(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    conversation_id: str\n    role: str  # 'user' or 'assistant'\n    content: str\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n\nclass ConversationModel(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    user_id: str\n    title: str = \"New Conversation\"\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)\n\nclass MoodModel(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    user_id: str\n    mood_type: str  # 'great', 'good', 'okay', 'sad', 'anxious', 'angry'\n    note: Optional[str] = None\n    timestamp: datetime = Field(default_factory=datetime.utcnow)\n\nclass JournalModel(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    user_id: str\n    title: str\n    content: str\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)\n\n# Request/Response Models\nclass ChatRequest(BaseModel):\n    message: str\n    conversation_id: Optional[str] = None\n    user_id: str = \"default_user\"  # For now, using default user\n\nclass ChatResponse(BaseModel):\n    message: str\n    conversation_id: str\n\nclass MoodRequest(BaseModel):\n    user_id: str = \"default_user\"\n    mood_type: str\n    note: Optional[str] = None\n\nclass JournalRequest(BaseModel):\n    user_id: str = \"default_user\"\n    title: str\n    content: str\n\nclass JournalUpdateRequest(BaseModel):\n    title: Optional[str] = None\n    content: Optional[str] = None\n\n# Routes\n@api_router.get(\"/\")\nasync def root():\n    return {\"message\": \"SoulNest API - Your safe emotional space \ud83e\udd0d\"}\n\n@api_router.post(\"/chat\", response_model=ChatResponse)\nasync def chat(request: ChatRequest):\n    try:\n        # Get or create conversation\n        if request.conversation_id:\n            conversation = await db.conversations.find_one({\"id\": request.conversation_id})\n            if not conversation:\n                raise HTTPException(status_code=404, detail=\"Conversation not found\")\n        else:\n            # Create new conversation\n            new_conversation = ConversationModel(\n                user_id=request.user_id,\n                title=request.message[:50] if len(request.message) > 50 else request.message\n            )\n            await db.conversations.insert_one(new_conversation.dict())\n            conversation_id = new_conversation.id\n            request.conversation_id = conversation_id\n        \n        # Save user message\n        user_msg = MessageModel(\n            conversation_id=request.conversation_id,\n            role=\"user\",\n            content=request.message\n        )\n        await db.messages.insert_one(user_msg.dict())\n        \n        # Get conversation history\n        messages = await db.messages.find(\n            {\"conversation_id\": request.conversation_id}\n        ).sort(\"timestamp\", 1).to_list(100)\n        \n        # Initialize LLM chat\n        llm_chat = LlmChat(\n            api_key=EMERGENT_LLM_KEY,\n            session_id=request.conversation_id,\n            system_message=SOULNEST_SYSTEM_MESSAGE\n        ).with_model(\"openai\", \"gpt-5.2\")\n        \n        # Generate response\n        user_message = UserMessage(text=request.message)\n        ai_response = await llm_chat.send_message(user_message)\n        \n        # Save AI response\n        ai_msg = MessageModel(\n            conversation_id=request.conversation_id,\n            role=\"assistant\",\n            content=ai_response\n        )\n        await db.messages.insert_one(ai_msg.dict())\n        \n        # Update conversation timestamp\n        await db.conversations.update_one(\n            {\"id\": request.conversation_id},\n            {\"$set\": {\"updated_at\": datetime.utcnow()}}\n        )\n        \n        return ChatResponse(\n            message=ai_response,\n            conversation_id=request.conversation_id\n        )\n    except Exception as e:\n        logging.error(f\"Chat error: {str(e)}\")\n        raise HTTPException(status_code=500, detail=str(e))\n\n@api_router.get(\"/conversations\", response_model=List[ConversationModel])\nasync def get_conversations(user_id: str = \"default_user\"):\n    conversations = await db.conversations.find(\n        {\"user_id\": user_id}\n    ).sort(\"updated_at\", -1).to_list(100)\n    return [ConversationModel(**conv) for conv in conversations]\n\n@api_router.get(\"/conversations/{conversation_id}/messages\", response_model=List[MessageModel])\nasync def get_messages(conversation_id: str):\n    messages = await db.messages.find(\n        {\"conversation_id\": conversation_id}\n    ).sort(\"timestamp\", 1).to_list(1000)\n    return [MessageModel(**msg) for msg in messages]\n\n@api_router.post(\"/mood\", response_model=MoodModel)\nasync def log_mood(request: MoodRequest):\n    mood = MoodModel(\n        user_id=request.user_id,\n        mood_type=request.mood_type,\n        note=request.note\n    )\n    await db.moods.insert_one(mood.dict())\n    return mood\n\n@api_router.get(\"/moods\", response_model=List[MoodModel])\nasync def get_moods(user_id: str = \"default_user\", limit: int = 30):\n    moods = await db.moods.find(\n        {\"user_id\": user_id}\n    ).sort(\"timestamp\", -1).to_list(limit)\n    return [MoodModel(**mood) for mood in moods]\n\n@api_router.post(\"/journal\", response_model=JournalModel)\nasync def create_journal(request: JournalRequest):\n    journal = JournalModel(\n        user_id=request.user_id,\n        title=request.title,\n        content=request.content\n    )\n    await db.journals.insert_one(journal.dict())\n    return journal\n\n@api_router.get(\"/journals\", response_model=List[JournalModel])\nasync def get_journals(user_id: str = \"default_user\"):\n    journals = await db.journals.find(\n        {\"user_id\": user_id}\n    ).sort(\"created_at\", -1).to_list(100)\n    return [JournalModel(**journal) for journal in journals]\n\n@api_router.get(\"/journals/{journal_id}\", response_model=JournalModel)\nasync def get_journal(journal_id: str):\n    journal = await db.journals.find_one({\"id\": journal_id})\n    if not journal:\n        raise HTTPException(status_code=404, detail=\"Journal not found\")\n    return JournalModel(**journal)\n\n@api_router.put(\"/journals/{journal_id}\", response_model=JournalModel)\nasync def update_journal(journal_id: str, request: JournalUpdateRequest):\n    update_data = {\"updated_at\": datetime.utcnow()}\n    if request.title:\n        update_data[\"title\"] = request.title\n    if request.content:\n        update_data[\"content\"] = request.content\n    \n    result = await db.journals.update_one(\n        {\"id\": journal_id},\n        {\"$set\": update_data}\n    )\n    \n    if result.matched_count == 0:\n        raise HTTPException(status_code=404, detail=\"Journal not found\")\n    \n    journal = await db.journals.find_one({\"id\": journal_id})\n    return JournalModel(**journal)\n\n@api_router.delete(\"/journals/{journal_id}\")\nasync def delete_journal(journal_id: str):\n    result = await db.journals.delete_one({\"id\": journal_id})\n    if result.deleted_count == 0:\n        raise HTTPException(status_code=404, detail=\"Journal not found\")\n    return {\"message\": \"Journal deleted successfully\"}\n\n# Include the router in the main app\napp.include_router(api_router)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_credentials=True,\n    allow_origins=[\"*\"],\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@app.on_event(\"shutdown\")\na
